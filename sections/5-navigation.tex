\subsection{Building a Cost Map} \label{cost-map}
The robot uses a cost map to navigate its environment. Similar to the map described in section 2.2, it is a grid of squares, each representing a \qty{5}{cm^2} area in the real-world \parencite{macenskiDesksROSMaintainers2023}. Each square is assigned a cost: an integer ranging from 0 to 255. The higher the cost, the harder it is for the robot to cross that square; thus, the pathfinding algorithm finds a path with the lowest cost. There are two special integers: 254 signifies impassable squares, and 255 indicates unknown squares.

This cost map, called Layered Costmap, is generated by stacking multiple dynamic layers originating from different sources. Periodically, the cost map is updated by refreshing the layers with new sensor measurements. ROS2 provides many layers by default:
\begin{enumerate}
    \item \textbf{Static layer}: This layer is a pre-built map of the environment, typically created by manually navigating the robot and collecting sensor data (as described in section \ref{map}). It is accessed by ``[subscribing] to an OccupancyGrid topic'' \parencite{macenskiDesksROSMaintainers2023}. Due to continuous mapping, this map can evolve over time, capturing changes in the environment.
    \item \textbf{Obstacle layer}: Using the highly accurate LIDAR sensor, this layer detects the immediate obstacles around the robot. The hit points measured by the sensor are treated with absolute certainty. The robot assumes there is empty space between itself and any hit point it measures.
    \item \textbf{Inflation layer}: Based on occupancy data of other layers, this layer adds a safety buffer zone around obstacles to prevent collisions. For a given square located at ($x,y$) in the map close to an obstacle, its cost is increased using the equation
          \[
              cost(x,y)=(cost_\text{lethal}-1)e^{-\omega_{scale}(d_0-r)},
          \]
          where ``$d_0$ is the distance [from square ($x,y$)] to the [nearest] obstacle, $cost_\text{lethal}$ is the [cost of that nearest obstacle], and $r$ is the [robot's] inscribed radius...'' \parencite{macenskiDesksROSMaintainers2023}. The cost scaling factor ($\omega_{scale}$) is a constant that controls the steepness of cost increase around obstacles. A higher value will result in a steeper increase.
    \item \textbf{Keepout layer}: This layer can increase the cost of certain squares using input masks, even if there are no obstacles. It is used to make the robot avoid certain areas.
    \item \textbf{Speed layer}: This layer can define zones with specific speed restrictions. It is used to make the robot slow down in certain areas.
\end{enumerate}
An example cost map is shown in Figure \ref{fig:rviz}.

\begin{figure}[!htb]
    \includegraphics[width=8cm]{rviz.png}
    \centering
    \caption{Example cost map displayed by RViz.}
    \label{fig:rviz}
\end{figure}
\FloatBarrier

\subsection{Dijkstra's Algorithm} \label{dijkstra}
Dijkstra's algorithm is used to find the shortest path between two points in a network of nodes \parencite{computerphileDijkstraAlgorithmComputerphile2017}. As an example, consider the network shown in Figure \ref{fig:dijkstra}a. The goal is to find the shortest path from node A to node E. The following steps outline how to solve this problem using Dijkstra's algorithm.

\begin{figure}[!htb]
    \centering
    \subfloat[\centering Shortest path is unknown] {{\includegraphics[width=5cm]{dijkstra1} }}
    \qquad
    \subfloat[\centering Shortest path is found]{{\includegraphics[width=5cm]{dijkstra2} }}
    \caption{Example of a network of nodes where the goal is to find the shortest path from node A to node E.}
    \label{fig:dijkstra}
\end{figure}

\filbreak

\begin{enumerate}
    \item \textbf{Current node: A}\\
          $\text{closed} = \{A\}$\\
          \def\arraystretch{1.5}
          \begin{tabular}{ |c|c|c|c|c|c|c|c| }
              \hline
                             & A & B & C & D & E        \\
              \hline
              Distance ($d$) & 0 & 2 & 5 & 3 & $\infty$ \\
              \hline
              Previous node  & - & A & A & A & A        \\
              \hline
          \end{tabular}
    \item \textbf{Current node: B}\\
          Since B is the closest node to A, it is added to the closed list.\\
          $\text{closed} = \{A,B\}$
          \begin{itemize}
              \item $d_C=\min(5,2+BC)=\min(5,2+4)=\min(5,6)=5$
              \item $d_D=\min(3,2+BD)=\min(3,2+\infty)=\min(3,\infty)=3$
              \item $d_E=\min(\infty,2+BE)=\min(\infty,2+\infty)=\min(\infty,\infty)=\infty$
          \end{itemize}
          Since there are no changes in the distance values, travelling from A to B directly is the shortest distance. Therefore, the previous nodes remain the same.
    \item \textbf{Current node: D}\\
          Node D is added to the closed list because it is the next shortest path.\\
          $\text{closed} = \{A,B,D\}$
          \begin{itemize}
              \item $d_C=\min(5,3+DC)=\min(5,3+1)=\min(5,4)=4$
              \item $d_E=\min(\infty,3+DE)=\min(\infty,3+6)=\min(\infty,9)=9$
          \end{itemize}
          \def\arraystretch{1.5}
          \begin{tabular}{ |c|c|c|c|c|c|c|c| }
              \hline
                             & A & B & C & D & E \\
              \hline
              Distance ($d$) & 0 & 2 & 4 & 3 & 9 \\
              \hline
              Previous node  & - & A & D & A & D \\
              \hline
          \end{tabular}
    \item \textbf{Current node: C}\\
          Node C is added to the closed list because it has the shortest path from D.\\
          $\text{closed} = \{A,B,D,C\}$
          \begin{itemize}
              \item $d_E=\min(9,4+CE)=\min(9,4+2)=\min(9,6)=6$
          \end{itemize}
          \def\arraystretch{1.5}
          \begin{tabular}{ |c|c|c|c|c|c|c|c| }
              \hline
                             & A & B & C & D & E \\
              \hline
              Distance ($d$) & 0 & 2 & 4 & 3 & 6 \\
              \hline
              Previous node  & - & A & D & A & C \\
              \hline
          \end{tabular}
    \item It is possible to find the shortest path by working backwards from E ($E \leftarrow C \leftarrow D \leftarrow A$), as shown in Figure 4b. This path has a length of 6.
\end{enumerate}

\subsection{Global Path Planner} \label{global-planner}
In order for the robot to move towards a goal, a pathfinding algorithm is needed. In this project, the Navigation Function (NavFn) planner plugin from the Nav2 package is used \parencite{NavFnPlannerNav2}. To compute an optimal path to the goal, this plugin uses a potential field called a navigation function. This field acts like a force that guides the robot's movement away from obstacles and towards the goal \parencite{philippsenInterpolatedDynamicNavigation2005}. It is represented by a grid map with each square having a discrete crossing time. As the navigation function is generated, similar to a ripple in water, by propagating a wavefront outwards from the goal until it reaches the robot's starting position, the crossing time is the time at which the wavefront crosses a grid square. The wavefront's position at a time $t$ is given by
\[
    \Gamma (t)=\{(x,y) \mid T(x,y)=t\}.
\]

The potential field is built from the cost map described in section \ref{cost-map}. The costs on the cost map are converted to wavefront propagation speeds ($F$) \parencite{philippsenInterpolatedDynamicNavigation2005}. Due to the cost depicting the difficulty of crossing a grid square, lower costs are converted to higher speeds, while higher costs are converted to lower speeds. The propagation speeds are used to determine the crossing times of the grid squares. If $F(x,y)>0$, the navigation function ($T$) follows the differential equation
\[
    |\nabla T|F=1.
\]
As the navigation function is represented by a discrete grid map, this equation needs to be written in a discrete notation. For a given grid square located at ($i,j$), its crossing time ($T$) can be found using the equation
\begin{equation} \label{eq:discrete-for-navfn}
    \max(D_{ij}^{-x}T,-D_{ij}^{+x},0)^2+\max(D_{ij}^{-y}T,-D_{ij}^{+y},0)^2=\frac{1}{F_{ij}^2},
\end{equation}
where $F_{ij}$ is the propagation speed at the grid square, and each $D_{ij}$ is the difference quotient along its respective axis. The difference quotient, also called Newton's quotient, gives the average rate of change of a function between two points \parencite{DifferenceQuotient2023}. It is given by
\[
    f'(x)\approx\frac{f(x+h)-f(x)}{h}
\]
The true derivative of the function is obtained by taking $\lim\limits_{h\to0}$ of this equation. Looking at equation \ref{eq:discrete-for-navfn}, only two neighbouring squares (located on different axes) at most will be involved in the crossing time computation \parencite{philippsenInterpolatedDynamicNavigation2005}. For example, in the scenario shown in Figure \ref{fig:wavefront-expansion}, supposing that the neighbouring cells are B and C and that $T_B\leqslant T_C$, the quadratic equation to find the crossing time ($T$) of square ($i,j$) is
\begin{equation} \label{eq:crossing-time-quadratic}
    (T-T_B)^2+(T-T_C)^2=\frac{h^2}{F^2},
\end{equation}
where $T_B$ and $T_C$ are the crossing times of the neighbouring squares, h is the size of a square (\qty{5}{cm}), and ``[$F_{ij}$] is the propagation speed at [square] ($i,j$)'' \parencite{philippsenInterpolatedDynamicNavigation2005}. In order to always obtain a real solution for the crossing time ($T$), a fallback quadratic equation is needed; thus, when $T_C-T_A\geqslant h/F$, equation \ref{eq:crossing-time-quadratic} becomes
\[
    (T-T_A)^2=\frac{h^2}{F^2}.
\]
Equation \ref{eq:crossing-time-quadratic} not having a real solution indicates that the wavefront is not able to reach square ($i,j$) based on the information provided about its neighbouring squares and the wavefront's propagation speed.
%\todo{Maybe show quadratic expansion}

\begin{figure}[!htb]
    \begin{TAB}(e,1cm,1cm){|c|c|c|}{|c|c|c|}
        & A &    \\
        D & ($i,j$) & B \\
        & C &    \\
    \end{TAB}
    \centering
    \caption{Wavefront expansion}
    \label{fig:wavefront-expansion}
\end{figure}

To find the fastest crossing time for a given square, a Dijkstra-like algorithm is used to determine which square to update \parencite{macenskiDesksROSMaintainers2023, philippsenInterpolatedDynamicNavigation2005}. This results in the crossing times always increasing as the wavefront propagates further; hence, the goal is the navigation function's only minimum. A bicubic interpolation can then be applied to the navigation function to make it continuous, as shown in Figure \ref{fig:navfn}, and the optimal path can be found using gradient descent, an iterative minimization algorithm \parencite{GradientDescent2024}. Gradient descent works by taking ``repeated steps in the opposite direction of the gradient'' \parencite{GradientDescent2024}. It is applied iteratively from the initial position of the robot to the goal position. While this path is initially planned for the robot, it doesn't directly follow it. A separate local path planner, explained in section  \ref{local-planner}, is used for real-time movement control.

\begin{figure}[!htb]
    \centering
    \subfloat[\centering Non-interpolated crossing time grid]{{\includegraphics[width=5cm]{navfn-discrete.jpg} }}
    \qquad
    \subfloat[\centering Bicubic interpolation of navigation function]{{\includegraphics[width=5cm]{navfn-smooth.jpg} }}
    \caption{3D representation of how an example discrete navigation function is smoothed out for the gradient descent.}
    \label{fig:navfn}
\end{figure}

% A minimum travel cost is used so that the cost increases as the field propagates further.

\filbreak

\subsection{Local Path Planner} \label{local-planner}
After a path is generated by the global path planner, described in section \ref{global-planner}, the local path planner handles issuing linear and angular velocities ($v,\omega$) for the robot to follow the path \parencite{macenskiDesksROSMaintainers2023}. This planner serves to avoid new obstacles, make the path smoother, and keep movements steady. It uses the Dynamic Window Approach (DWA), which considers a range of physically possible linear and angular ``velocities that can be reached within the next time interval,'' as shown in Figure \ref{fig:dwa} \parencite{robotmaniaDynamicWindowApproach2020}. Many velocities would not be possible due to the limited torque exerted by the robot's motors. These parameters translate to circular arcs, which can be repeatedly adjusted every cycle to estimate the robot's intended path. All the paths generated by DWA are scored using the equation
\[
    \alpha heading(v,\omega) + \beta dist(v,\omega) + \gamma vel(v,\omega),
\]
where ``$heading(v,\omega)$ is a measure of distance to the goal, $dist(v,\omega)$ is the distance to the nearest obstacle on the trajectory, and $vel(v,\omega)$ encourages moving at full speed'' \parencite{macenskiDesksROSMaintainers2023}. These are called critic functions. $\alpha$, $\beta$, and $\gamma$ are constants used to change the weight of each critic function. In each cycle, the robot follows the path with the best score. ROS2 has many other integrated critic functions as well, including ``goal alignment,... path alignment, path distance, prefer forward motion, anti-twirling, anti-oscillation, and traversed cost by footprint or center value'' \parencite{macenskiDesksROSMaintainers2023}.

\begin{figure}[!htb]
    \includegraphics[width=6cm]{dwa.png}
    \centering
    \caption{Example of possible velocities considered by the Dynamic Window Approach (DWA) \parencite{robotmaniaDynamicWindowApproach2020}.}
    \label{fig:dwa}
\end{figure}
